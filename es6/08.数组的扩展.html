<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>数组的扩展</title>
</head>
<body>
  
  <script>
    //1.扩展运算符
    //扩展运算符是三个点...,它好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列
    console.log(...[1,2,3]);      //1 2 3
    console.log(1,...[2,3,4],5);  //1 2 3 4 5
    [...document.querySelectorAll('div')];//[<div>,<div>,<div>]
    //该运算符注意用于函数调用
    function push(array,...items) {
      array.push(...items);
      }
      function add(x,y) {
        return x + y;
        }
    const numbers = [4,38];
    add(...numbers); //42
    //上面代码中,array.push(...items)和add(...numbers)这两行,都是函数的调用,它们都使用扩展运算符,该运算符将一个数组变成参数序列

    //扩展运算符与正常的函数可以结合使用,非常灵活
    function f(v,w,x,y,z) {
      console.log(v,w,x,y,z);
      }
      const args = [0,1];
      f(-1,...args,2,...[3]);  //-1 0 1 2 3
    //扩展运算符还可以放置表达式
    const arr = [
      ...(x > 0 ? ['a'] : []),'b',
    ];
    //如果扩展运算符后面是一个空数组,则不产生任何后果
    [...[],1]  //[1]
    //注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用，否则就会报错。
    (...[1,2]);   //Uncaught SyntaxError: Unexpected number
    //console.log((...[1,2]))  //Uncaught SyntaxError: Unexpected number
    //上面两种情况都会报错，因为扩展运算符所在的括号不是函数调用，而console.log(...[1, 2])就不会报错，因为这时是函数调用。

    //替代函数的apply方法
    //由于扩展运算符可以展开数组,所以不再需要apply方法将数组转为函数的参数
    //es5写法
    function f(x,y,z) {  }
    var args = [0,1,2];
    f.apply(null,args);

    //ES6的写法
    function f(x,y,z) {  }
    let args = [0,1,2];
    f(...args);

    //下面扩展运算符取代apply方法的一个实际例子,应用Math.max方法,简化求出一个数组最大元素写法
    //ES5写法
    Math.max.apply(null,[14,3,77])    //77
    //ES6写法
    Math.max(...[14,,3,77]);      //77
    //等同于
    Math.max(14,3,77);      //77
    //上面代码中,由于Javascript不提供求数组最大元素的函数,所以只能套用Math.max函数,将数组转为一个参数序列,
    //然后求最大值,有了扩展运算符以后就可以直接用Math.max

    //另外例子是通过push函数,将一个数组添加到另一个数组的尾部
    //ES5的写法
    var arr1 = [0,1,2];
    var arr2 = [3,4,5];
    Array.prototype.push.apply(arr1,arr2);
    //ES6的写法
    let arr1 = [0,1,2];
    let arr2 = [3,4,5];
    arr1.push(...arr2);
    //ES5写法中,push方法的参数不能使数组,只好通过apply方法变通使用push方法。有了扩展运算符就可以直接将数组传入push方法。
    //es5
    new (Date.bind.apply(Date,[null,2015,1,1]));
    //es6
    new Date(...[2015,1,1]);

    //扩展运算符的应用
    //(1)复制数组
    //数组是复合数据类型,直接复制的话,只能复制指向底层数据结构的指针,而不是克隆一个全新的数组
    const a1 = [1,2];
    const a2 = a1;
    a2[0] = 2;
    console.log(a1); //[2,2]
    //上面代码中,a2并不是a1的克隆,而是指向同一份数据的另外一个指针,修改a2,会导致a1变化
    //ES5只能通过变通方法来复制数组
    const a1 = [1,2];
    const a2 = a1.concat();
    a2[0] = 2;
    console.log(a1); //[1,2]
    //上面的代码a1会返回原来数组的克隆,再修改a2就不会对a1产生影响
    //扩展运算符提供复制数组的简便写法
    const a1 = [1,2];
    //写法1
    const a2 = [...a1];
    //写法2
    const [...a2] = a1;
    //上面两种写法都可以克隆a1

    //合并数组
    //扩展运算符提供数组合并的新写法
    const arr1 = ['a','b'];
    const arr2 = ['c'];
    const arr3 = ['d','e'];
    //ES5的合并数组
    console.log(arr1.concat(arr2,arr3));//["a", "b", "c", "d", "e"]
    //ES6的合并数组
    console.log([...arr1,...arr2,...arr3]);//["a", "b", "c", "d", "e"]
    //不过这两种方法都是浅拷贝,使用的时候需要注意
    const a1 = [{foo:1}];
    const a2 = [{bar:2}];
    const a3 = a1.concat(a2);
    const a4 = [...a1,...a2];
    a3[0] === a1[0]; //true
    a4[0] === a1[0]; //true
    //a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。

    //与解构赋值结合
    //扩展运算符可以与解构赋值结合起来,用于生产数组
    //ES5
    a = list[0],rest = list.slice(1);
    //ES6
    [a,...rest] = list;
    //下面是另外一些例子
    const [first,...rest] = [1,2,3,4,5];
    console.log(first); //1
    console.log(rest);  //[2,3,4,5]
    const [first,...rest] = [];
    console.log(first);//undefined
    console.log(rest);//[]
    const [first,...rest] = ["foo"];
    console.log(first);//foo
    console.log(rest);//[]
    //如果将扩展运算符用于数组赋值,只能放在参数的最后一位,否则会报错
    const [...butLast,last] = [1,2,3,4,5];//报错
    const [first,...middle,last] = [1,2,3,4,5];//报错
    
    //字符串
    //扩展运算符还可以将字符串转为真正的数组。
    console.log([...'hello']);//["h", "e", "l", "l", "o"]
    //上面的写法有一个好处就是能够正确识别四个字节的Unicode字符
    'x\uD83D\uDE80y'.length // 4
    //[...'x\uD83D\uDE80y'].length // 3
    //上面代码第一种写法,Javascript会将四个字节的Uncode字符,识别为2个字符,采用扩展运算符就没有这个问题，
    //因此正确返回字符串长度的函数可以这样写
      function length(str) { 
        return [...str].length;
       }
       length('x\uD83D\uDE80y') // 3
    //凡是涉及到操作四个字节的Unicode字符的函数都有这个问题,最好都用扩展运算符改写
    let str = 'x\uD83D\uDE80y';
    str.split('').reverse().join();  // "y,�,�,x"
    [...str].reverse().join();       //"hole,y,🚀,x"
    //上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。

    //实现了Iterator接口的对象
    //任何Iterator接口的对象都可以用扩展运算符转为真正的数组
    let nodeList = document.querySelectorAll('div');
    let array = [...nodeList];
    //querySelectorAll方法返回的是一个NodeList对象,它不是数组而是一个类似数组的对象,扩展运算符可以将其转为真正的数组，因为 NodeList对象实现了Iterator
    //对应那些没有部署Iterator接口的类似数组的对象,扩展运算符就无法将其转为真正的数组
    let arrayLike = {
      '0':'a',
      '1':'b',
      '2':'c',
      length:3
    }
    let arr = [...arrayLike];   // TypeError: Cannot spread non-iterable object.
    console.log(Array.from(arrayLike));      //["a", "b", "c"]
    //arrayLike是一个类似数组的对象,但是没有部署Iterator接口,扩展运算符就会报错，这是，可以改用Array.from方法将arrayLike转为真正的数组
    
    //Map和Set结构,Generator函数
    //扩展运算符内部调用的是数据结构的Iterator接口,因此只要具有Iterator接口的对象,都可以用扩展运算符,比如Map结构
    let map = new Map([[1,'one'],[2,'two'],[3,'three'],]);
    let arr = [...map.keys()];  //[1,2,3]
    //Generator函数运行后,返回一个遍历器对象,因此也可以使用扩展运算符
      const go = function*(){
        yield 1;
        yield 2;
        yield 3;
      };
      [...go()] // [1, 2, 3]
      //上面代码遍历go是一个Generator函数,执行后返回一个遍历器对象,对这个遍历器对象执行扩展运算符,就会将内部遍历得到的值,转为一个数组

      //如果没有Iterator接口的对象,使用扩展运算符将会报错
      const obj = {a:1,b:2};
      let arr = [...obj]; //TypeError: Cannot spread non-iterable object
    


    //2.Array.from()
    //Array.from方法用于将两类对象转为真正的数组:类似数组的对象和可遍历的对象
    //下面是类数组对象通过Array.from转为真正的数组
    let arrayLike = {
      '0': 'a',
      '1': 'b',
      '2': 'c',
      length: 3
    }
    //ES5的写法
    let arr1 = [].slice.call(arrayLike);   // ['a', 'b', 'c']
    //ES6的写法
    let arr2 = Array.from(arrayLike);      // ['a', 'b', 'c']
    //实际应用中,常见的类似数组的对象是Dom操作返回的NodeList集合,以及函数内部的arguments对象,Array.from都可以将它们转为真正的数组
    //NodeList对象
    let ps = document.querySelectorAll('p');
    Array.from(ps).filter(p => {
      return p.textContent.length>100;
    })
    //arguments对象
    function foo() {
      var args = Array.from(arguments);
    }
    //querySelectAll方法返回的是一个类似数组的对象,可以将这个对象转为真正的数组,再使用filter方法

    //只要部署了Iterator接口的数据结构,Array.from都能将其转为数组
    console.log(Array.from('hello'));
    let namesSet = new Set(['a','b']);
    console.log(Array.from(namesSet));
    //如果参数是一个真正的数组,Array.from会返回一个一模一样的新数组
    console.log(Array.from([1,2,3]));

    //值得提醒的是扩展运算符(...)也可以将某些数据结构为数组
    function foo() {
       const args = [...arguments];
      }
    //NodeList对象
    console.log([...document.querySelectorAll('div')]);
    //扩展运算符背后调用的是遍历接口(Symbol.iterator),如果一个对象没有部署这个接口就无法转换。
    //Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。
    console.log(Array.from({length:3}));
    //上面代码中,Array.from返回一个具有三个成员的数组,每个位置的值都是undefined,扩展运算符转换不了这个对象
    //对于没有补充该方法的浏览器可以使用es5的Array.protorype.slice方法代替
    const toArray = (() =>
      Array.from ? Array.from : obj => [].slice.call(obj)
    )();
    //Array.from可以接受第二个参数,作用类似于数组的map方法,用来对每个元素进行处理,将处理后的值放入返回的数组
    Array.from(arrayLike,x=>x * x);
    //等同于
    Array.from(arrayLike).map(x => x * x);
    console.log(Array.from([1,2,3],(x) => x * x));    //[1,4,9]

    //下面的例子取出一组Dom节点的文本内容
    let spans = document.querySelectorAll('span.name');
    //map()
    let names1 = Array.prototype.map.call(spans,s => s.textContent);
    //Array.from()
    let name2 = Array.from(spans,s => s.textContent);
    //下面的例子将数组中布尔值为false的成员转为0
    console.log(Array.from([1,,2,,3],(n)=>n || 0)); // [1, 0, 2, 0, 3]
    //另一个例子是返回各种数据的类型
    function typesOf() {
      return Array.from(arguments,value => typeof value)
      }
      typesOf(null,[],NaN);   // ['object', 'object', 'number']
      //如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。
      //Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，
      //你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。
      Array.from({length:2},()=>'jack'); //['jack', 'jack']
      //上面代码中,Array.from的第一个参数指定了第二个参数运行的次数,这种特性可以让该方法的用法变得灵活

      //Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。
      //因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。
      function countSymbols(string) {
         return Array.from(string).length;
        }
      console.log(countSymbols("hello")); //5

      //3.Array.of()
      //Array.of方法用于将一组值,转换为数组
      Array.of(3,11,8);    //[3,11,8]
      Array.of(3);         //[3]
      Array.of(3).length;  //1
      //这个方法的主要目的,是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。
      console.log(Array()); //[]
      console.log(Array(3));//[ , , , ]
      console.log(Array(3,11,8));//[3,11,8]
      //上面代码中,Array方法没有参数、一个参数、三个参数时,返回结果都不一样。只有当参数个数不少于2个时,Array()才会返回由参数组成的新数组,参数个数只有一个时,实际上是指定数组的长度
      //Array.of基本上可以用来替代Array()或new Array(),并且不存在由于参数不同而导致的重载。它的行为非常统一
      Array.of(); //[]
      Array.of(undefined); //[undefined]
      Array.of(1); //[1]
      Array.of(1,2); //[1,2]
      //Array.of总是返回参数值组成的数组。如果没有参数就返回一个空数组
      //Array.of方法可以用下面的代码模拟实现
      function ArrayOf() {
        return [].slice.call(arguments);
        }

      //4.数组实例的copyWithin()
      //数组实例的copyWithin方法,在当前数组内部,将指定位置的成员复制其他位置(会覆盖原有成员),然后返回当前数组。使用这个方法会修改当前数组
      Array.prototype.copyWithin(target,start = 0 , end = this.length);
      //三个参数,参数如果不是数组会自动转换成数值：
               //target(必需):从该位置开始替换数据,如果为负值,表示倒数。
               //start(可选):从该位置开始读取数据,默认为0。如果数组是负值，表示倒数
               //end(可选):到该位置停止读取数据,默认等于数组长度。如果为负值,表示倒数
       console.log([1,2,3,4,5].copyWithin(0,3));  //[4,5,3,4,5]
       //从3号位直到数组结束的成员(4和5),复制到重0号位开始的位置,结果覆盖了原来的1和2
       //更多的例子
       console.log([1,2,3,4,5].copyWithin(0,3,4)); //将3号位复制到0号位,[4,2,3,4,5]
       console.log([1,2,3,4,5].copyWithin(0,-2,-1));//-2相对于3号位，-1相对于4号位,[4,2,3,4,5]
       [].copyWithin.call({length:5,3:1},0,3);//将3号位复制到0号位,{0:1,3:1,length:5},前面是位数
       let i32a = new Int32Array([1,2,3,4,5]);
       i32a.copyWithin(0,2);//将2号位到数组结束,复制到0号位,[3,4,5,4,5]
       //对于没有部署TypeArray的copyWithin方法的平台
       //需要采用下面的写法
       [].copyWithin.call(new Int32Array([1,2,3,4,5]),0,3,4);//[4,2,3,4,5]

       //5.数组实例的find()和findIndex()
       //数组实例的find方法,用于找出第一个符合条件的数组成员,它的参数是一个回调函数,所用数组成员依次执行该回调函数,直到找出第一个返回值为true的成员,
       //然后返回该成员,如果没有符合条件的成员,则返回undefined
       [1,4,-5,10].find((n) => n<0); //-5,找出数组中第一个小于5的成员
       [1,5,10,15].find(function (value,index,arr) {
         return value>9;
         });//10
       //上面代码中,find方法的回调函数可以接受三个参数,依次为当前的值、当前的位置和原数组
       //数组实例的findIndex方法的用法与find方法非常类似,返回第一个符合条件的数组成员位置,如果所有成员不符合条件,则返回-1
       [1,5,10,15].findIndex(function (value,index,arr) {
         return value>9;
         })//2
        //find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。
        function f(v) {
          return v > this.age;
          }
        let person = {name:'John',age:20};
        [10,12,26,15].find(f,person);  //26
        //另外这两个方法可以发现NaN,弥补了数组的indexOf方法的不足。
        [NaN].indexOf(NaN);  //-1
        [NaN].findIndex(y => Object.is(NaN,y)); //0
        //上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。

        //6.数组实例的fill()
        //fill方法使用给定值,填充一个数组
        console.log(['a','b','c'].fill(7));  //[7,7,7]
        console.log(new Array(3).fill(7));   //[7,7,7]
        //上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。
        //fill方法还可以接受第二个和第三个参数,用于指定填充的起始位置和结束位置
        console.log(['a','b','c'].fill(7,1,2)); //['a','7','c']
        //上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。
        //注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。
        let arr = new Array(3).fill({name:"Mike"});
        arr[0].name = "Ben";
        console.log(arr); //[{name:"Ben"},{name:"Ben"},{name:"Ben"}]
        let arr = new Array(3).fill([]);
        arr[0].push(5);
        console.log(arr); //[[5],[5],[5]]

        //7.数组实例的entries(),keys()和values()
        //ES6提供三个新的方法--entries(),keys()和values()用于遍历数组。它们都返回一个遍历对象,可以用for...of循环遍历,
        //唯一区别是keys()是对健名的遍历、values()对健值的遍历,entries()是对键值对的遍历
        for(let index of ['a','b'].keys()){
          console.log(index);
        }//0 1
        for(let elem of ['a','b'].values()){
          console.log(elem);
        }//'a' 'b'
        for(let [index,elem]of ['a','b'].entries()){
          console.log(index,elem);
        }
        //0 "a"
        //1 "b"
        //如果不使用for...of循环,可以手动调用变流器对象的next方法,进行遍历
        let letter = ['a','b','c'];
        let entries = letter.entries();
        console.log(entries.next().value); //[0,"a"]
        console.log(entries.next().value); //[1,"b"]
        console.log(entries.next().value); //[2,"c"]

        //8.数组实例的includes()
        //Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。
        [1,2,3].includes(2);     //true
        [1,2,3].includes(4);     //false
        [1,2,NaN].includes(NaN); //true
        //该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。
        [1, 2, 3].includes(3, 3);  // false
        [1, 2, 3].includes(3, -1); // true
        //没有该方法之前,我们通常使用数组的indexof方法,检查是否包含某个值
        if(arr.indexOf(el)!== -1){

        }
        //indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。
        //二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。
        [NaN].indexOf(NaN); //-1
        //includes使用的是不一样的判断算法,就没有这个问题
        console.log([NaN].includes(NaN)); //true
        //下面代码用来检查当前环境是否支持该方法,如果不支持部署一个简易的替代版本
        const contains = (()=>
          Array.prototype.includes ? (arr,value) =>arr.includes(value)
          : (arr,value)=> arr.some(el => el === value)
        )();
        contains(["foo","bar"],"baz"); //false
        //Map 和 Set 数据结构有一个has方法，需要注意与includes区分。
        //Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。
        //Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。
        
        //9.数组实例的flat()、flatMap()
        //数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响
        console.log([1,2,[3,4]].flat());  //[1,2,3,4]
        //上面代码中,原数组的成员里面有一个数组,flat()方法将子数组的成员取出来,添加在原来的位置
        //flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。
        console.log([1,2,[3,[4,5]]].flat()); // [1, 2, 3, [4, 5]]
        console.log([1,2,[3,[4,5]]].flat(2));// [1,2,3,4,5],参数为2代表要"拉平"两层的嵌套数组
        //如果不管有多少层嵌套,都要转成一维数组可以用Infinity关键字作为参数
        [1,[2,[3]]].flat(Infinity);//[1,2,3]
        //如果原数组有空位,flat()方法会跳过空位
        [1,2, ,4,5].flat(); //[1, 2, 4, 5]
        //flatMap()方法对原数组的每个成员执行一个函数(相当于执行Array.prototype.map()),然后对返回值组成的数组执行flat()方法
        //该方法返回一个新数组,不改变原数组
        // 相当于 [[2, 4], [3, 6], [4, 8]].flat()
        console.log([2,3,4].flatMap((x)=> [x,x*2]));    //[2,4,3,6,4,8]
        //flatMap()只能展开一层数组
        // 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
        [1, 2, 3, 4].flatMap(x => [[x * 2]]);// [[2], [4], [6], [8]]
        //上面代码中,遍历函数返回的是一个双层的数组,但是默认只能展开一层,因此flatMap()返回的还是一个嵌套数组
        //flatMap()方法的参数是一个遍历函数,该函数可以接受三个参数,分别是当前数组成员、当前数组成员的位置(从零开始)、原数组
        //arr.flatMap(function callback(currentValue[,index[,array]]) {    }[,thisArg])
        //flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。


        //10.数组的空位
        //数组的空位指数组的某一个位置没有任何值。比如Array构造函数返回的数组都是空位
        console.log(Array(3));     //[ , , ,]
        //上面代码中,Array(3)返回一个具有3个空位的数组
        //注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。
        console.log(0 in [undefined,undefined,undefined]);  //true
        console.log(0 in [,,,]); //false
        //上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。
        //ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。forEach(), filter(), reduce(), every() 和some()都会跳过空位。
        //map()会跳过空位，但会保留这个值,join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。
        // forEach方法
        [,'a'].forEach((x,i) => console.log(i)); // 1
        // filter方法
        ['a',,'b'].filter(x => true) // ['a','b']
        // every方法
        [,'a'].every(x => x==='a') // true
        // reduce方法
        [1,,2].reduce((x,y) => x+y) // 3
        // some方法
        [,'a'].some(x => x !== 'a') // false
        // map方法
        [,'a'].map(x => 1) // [,1]
        // join方法
        [,'a',undefined,null].join('#') // "#a##"
        // toString方法
        [,'a',undefined,null].toString() // ",a,,"
        //ES6则是明确将空位转为undefined
        //Array.from方法会将数组的空位转为undefined,也就是说这个方法不会忽略空位
        console.log(Array.from(['a', , 'b']));   // [ "a", undefined, "b" ]
        //扩展运算符(...)也会将空位转为undefined
        [...['a','b']];    //['a',undefined,'b'];
        //copyWithin()会连空位一起拷贝
        console.log([,'a','b',,].copyWithin(2,0));  //[,"a",,"a"]
        //fill()会将空位视为正常的数组位置
        console.log(new Array(3).fill('a'));  //['a','a','a']
        //for...of循环也会遍历空位
        let arr = [, ,];
        for(let i of arr){
          console.log(1);
        };//1  1
        //上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。
        //entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。
        //entries()
        [...[,'a'].entries()] // [[0,undefined], [1,"a"]]
        // keys()
        [...[,'a'].keys()] // [0,1]
        // values()
        [...[,'a'].values()] // [undefined,"a"]
        // find()
        [,'a'].find(x => true) // undefined
        // findIndex()
        [,'a'].findIndex(x => true) // 0
        //由于空位处理规则非常不统一,所以建议避免出现空位
        
          
        
                
        
        
        
        

        
        
        
        
        
        

       
        
       
      

      
      
      


    
    
    
    
    




  
    
    
    

    





  </script>
</body>
</html>